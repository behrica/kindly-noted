
---
format:
  html:
    toc: true
    toc-depth: 4
    theme: [spacelab, notebooks/custom.scss]
    output-file: kindly_advice.html
highlight-style: solarized
code-block-background: true
include-in-header: {text: '<link rel = "icon" href = "data:," />'}

---
<style></style><style>.printedClojure .sourceCode {
  background-color: transparent;
  border-style: none;
}
</style>
<script src="kindly_advice_files/md-default0.js" type="text/javascript"></script><script src="kindly_advice_files/md-default1.js" type="text/javascript"></script>

::: {.sourceClojure}
```clojure
(ns kindly-advice
  (:require [scicloj.kindly-advice.v1.api :as kindly-advice]
            [scicloj.kindly.v4.kind :as kind]
            [scicloj.kindly.v4.api :as kindly]))
```
:::



# Kindly-advice

Kindly-advice is a small library to advise Clojure data visualization and notebook tools how to display forms and values, following the Kindly convention.

## Status
Kindly-advice will stabilize soon and is currently getting feedback from tool-makers.

## Goal

- provide **tools** with the necessary information to support Kindly

- have sensible defaults

- be user-extensible

## Asking for advice



::: {.sourceClojure}
```clojure
(-> {:value (kind/hiccup
             [:div [:h1 "hello"]])}
    kindly-advice/advise
    kind/pprint)
```
:::



::: {.printedClojure}
```clojure
{:value [:div [:h1 "hello"]],
 :meta-kind :kind/hiccup,
 :kind :kind/hiccup,
 :advice
 [[:kind/hiccup]
  [:kind/hiccup {:reason :metadata}]
  [:kind/vector {:reason :predicate}]
  [:kind/seq {:reason :predicate}]]}

```
:::



The `:kind` field is the important one, expressing the bottom line of the inference: Kindly-advice recommends the tool handles this value as Hiccup.

The tool's job will usually be to display the `:value` field based on the `:kind` field.

In the following exmple, we are asking for advice for given form (annotated by Kindly in this example).
Kindly-advice evaluates the form and adds the resulting value to complete the context. This completion will only take place if the value is missing. It is recommended that tools will take care of evaluation themselves and pass the complete context to Kindly-advice. Doing so allows the tool to handle Exceptions better, among other things.
Kindly-advice checks both the form and value for metadata. The metadata might not be present on the value.



::: {.sourceClojure}
```clojure
(-> {:form ^:kind/hiccup
     [:div [:h1 "hello"]]}
    kindly-advice/advise
    kind/pprint)
```
:::



::: {.printedClojure}
```clojure
{:form [:div [:h1 "hello"]],
 :value [:div [:h1 "hello"]],
 :meta-kind :kind/hiccup,
 :kind :kind/hiccup,
 :advice
 [[:kind/hiccup]
  [:kind/hiccup {:reason :metadata}]
  [:kind/vector {:reason :predicate}]
  [:kind/seq {:reason :predicate}]]}

```
:::


Sometimes, there is no inferred kind, as no metadata or relevant predicates say anything useful:


::: {.sourceClojure}
```clojure
(-> {:form '(+ 1 2)}
    kindly-advice/advise
    kind/pprint)
```
:::



::: {.printedClojure}
```clojure
{:form (+ 1 2), :value 3, :meta-kind nil, :advice []}

```
:::


In some situations, the kind inferred by predicates. Kindly-advice has a list of default predicates, which can be extended by the user. In the following eexample, it recognizes a dataset created by Tablecloth.


::: {.sourceClojure}
```clojure
(require '[tablecloth.api :as tc])
```
:::



::: {.sourceClojure}
```clojure
(-> {:value (tc/dataset {:x (range 4)})}
    kindly-advice/advise
    kind/pprint)
```
:::



::: {.printedClojure}
```clojure
{:value _unnamed [4 1]:

| :x |
|---:|
|  0 |
|  1 |
|  2 |
|  3 |
,
 :meta-kind nil,
 :kind :kind/dataset,
 :advice
 [[:kind/dataset {:reason :predicate}]
  [:kind/map {:reason :predicate}]]}

```
:::



## Examples

Kindly-advice is used by the following projects:

- [kind-portal](https://github.com/scicloj/kind-portal)

- [kind-clerk](https://github.com/scicloj/kind-clerk)

- [read-kinds](https://github.com/scicloj/read-kinds)

- [Clay](https://scicloj.github.io/clay/)




## Extending

One my extend kindly-advice to perform custom kind inference.

In the following example, we add our own advisor, which recognizes vectors beginning with a `:div` keyword as `:kind/hiccup`.



::: {.sourceClojure}
```clojure
(def my-advisor
  (fn [{:keys [value]}]
    (if (and (vector? value)
             (-> value first (= :div)))
      [[:kind/hiccup]])))
```
:::



::: {.sourceClojure}
```clojure
(kindly-advice/set-advisors!
 (cons #'my-advisor
       kindly-advice/default-advidors))
```
:::



::: {.printedClojure}
```clojure
(#'kindly-advice/my-advisor
 #function[scicloj.kindly-advice.v1.advisors/meta-kind-advisor]
 #function[scicloj.kindly-advice.v1.advisors/predicate-based-advisor/fn--9308])

```
:::



::: {.sourceClojure}
```clojure
(-> {:form '[:div [:p "hello"]]}
    kindly-advice/advise
    kind/pprint)
```
:::



::: {.printedClojure}
```clojure
{:form [:div [:p "hello"]],
 :value [:div [:p "hello"]],
 :meta-kind nil,
 :kind :kind/hiccup,
 :advice
 [[:kind/hiccup]
  [:kind/vector {:reason :predicate}]
  [:kind/seq {:reason :predicate}]]}

```
:::


<div style="background-color:grey;height:2px;width:100%;"></div>

<div><pre><small><small>source: <a href="https://github.com/scicloj/kindly-noted/blob/main/notebooks/kindly_advice.clj">notebooks/kindly_advice.clj</a></small></small></pre></div>